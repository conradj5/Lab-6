# Lab-6 Solution Notebook

1) Using IDA pro, it became evident that the string were being loaded using the LoadString method. However, we had no idea where the strings were coming from. Researching the MSDN for clues it became evident that all the string were stored in a string table, which I accessed using Resource Tuner 2 (which turned out to be a bad idea as it edited the binary). After many unsuccessful attempts to edit the string table or hook onto the LoadString function call, Professor deep instructed us to turn our attention towards the VirtualProtect method. However, we had no idea where the string was being stored. Eventually after setting many breakpoints and stepping through the LoadString method, I found the strings in the .rscs section, which was only populated at runtime. After tracking the string through PE Studio, a hex editor, and Resource Hacker, we calculated the raw offset. Once we were able to locate the original message, we could change the protection of its memory with VirtualProtect and then writing to the raw address space without desired message.  

2) Started by setting breakpoints and discovered what values were being changed with a defined SetInt function. However, using this method was no good as the SetInt method only took a byte for the data value being passed when we needed more than just a byte for the value 1000. Within this function was an API function call RegSetValueExW. In this method, there were also calls to RegCreateKeyW and RegCloseKeyW. Using these methods was achieved rather easily by setting multiple breakpoints and observing the values being passed to each function. In order to change the number of wins, we needed the registry key number and the path to the registry key. With this information we were able to set the value of the _pszWon registry value which was used to store the total number of wins. 

3) First we discovered an area in the IDA Pro disassembly that clearly represented a switch statement. After a little investigating, we discovered that this switch statement handled all the keyboard short-cuts. We set up breakpoints to find where Ctrl-Shift_F10 would pop-up. When we finally located the Ctrl-Shift_F10 case, we were able to locate the prompt that comes up and then saw the prompt to choose "Abort, Retry, Cancel". We followed the path taken by the Abort choice and found a function called cheating. Following the path of this function led us to discover that setting the variable cheating to 2 forces a win. The code to achieve this is simply changing the value of the cheating variable.   

4/5) We explored a couple different solutions to this problem. One solution was to implement a keyboard listener using a loop that would monitor for a certain keyboard combinations. To set the combinations of the new keyboard short-cuts, we used the GetKeyState() function. By using this function, we could implement our own functionality for a desired keystrike. Another solution was to use SetWindowsHookEx(). The idea was to use this to intercept the keyboard messages and to execute our own desired code. However, like with Problem 1, we were unable to figure out how to implement it. The last idea we had was to write a new accelerator table and to replace the Freecell with it. Using Resource Hacker, we found the accelerator table used in the program. However, after many hours of trying to 'replace' the freecell accelerator table we simply could not find any method that would achieve what we wanted. Overriding the current accelerator table was the biggest hurdle. We were able to discover how to destroy the Freecell accelerator table, but replacing it was not clear. 

After some time and greater discussion, we revisited each idea one by one and eventually found a way implement our own accelerator table concurrently alongside the freecel accelerator table. We defined our own accelerator table, loaded the table, and made a loop to listen for all messages. After this we could easily check the value of the messages being passed and execute our own code according to the keystroke being used. All keyboard messages are intercepted by both the freecell and our own dll injected table. For the fourth problem, we simply needed to define a new keystroke that matched the ID of the Ctrl-Shift-F10 keystroke. The fifth problem requred hookin gonto the messages and loading the lParam of each intercepted message, check if it was the Ctrl-Shift-F2 keystroke. A simple if statement and a call to a defined funciton alowed us to easily win the game. However, after winning my code unixplicably crashes after trying to load a new game.
